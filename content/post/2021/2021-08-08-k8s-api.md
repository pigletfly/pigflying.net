---
layout: post
title: 16 件关于 Kubernetes APIs 和 CRDs 你所不知道的事情
date: '2021-08-08T09:34:00+08:00'
tags: [kubernetes]
---

第 15 个会震惊你！

如果你对 kubernetes 很熟悉，那么你很可能对 kubernetes API 和 controller 有所了解：调谐循环查看 api 中存储的数据，并且努力让集群中的状态和声明的 API 状态相匹配。

这是一个相当强大的模式，随着时间的推移，已经证明了它的价值。但是，尽管核心思想看起来很简单，但一旦你从表面上看，有很多细节可能会令人惊讶

### 1. 并不是所有的 kubernetes apis 都有对应的控制器

kubernetes 控制平面通常分为两种职责：API 和控制器。

大多数 kubernetes 发行版都在单独的 Pod 中运行核心 apis 和核心控制器:

```bash
$ k -n kube-system get pods
NAME                                         READY   STATUS    RESTARTS   AGE
kube-apiserver-kind-control-plane            1/1     Running   0          23m
kube-controller-manager-kind-control-plane   1/1     Running   0          23m
```

`kube-apiserver` 主要负责将 api 数据存储到后端存储中，这通常是 etcd。

`kube-controller-manager` 在这些 api 的内容上运行一系列的调和循环。随着时间的推移，这些控制器确保达到（或不达到）预期的状态，并通过 api 报告状态。

而通常这就是 kubernetes API 的工作方式：通过 API 创建期望的状态，期望的状态被存储，控制器以非同步方式工作，使集群状态与期望的状态相匹配。

例如：deployment api 允许你创建一个定义 Pod 的 deployment对象。Deployment 控制器（在controller-manager中运行）根据 deployment 对象创建副本集并更新状态。

如果你完全停止控制器管理器，并试图创建一个像 deployment 这样的对象，这一点就特别明显。

如果没有 controller-manager 运行，deployment 对象（仍然可以被创建！），但是没有状态，也不会创建 Pod。

但实际上，有一小部分 api 并不直接由控制器以这种方式管理。`SubjectAccessReview` 就是其中之一。

即使没有 controller-manager，SubjectAccessReview 也会响应一个状态。

还有一个你可能很熟悉的 api，它也可以在没有 controller-manager 的情况下使用。

Pods 在没有 controller-manager 的情况下也可以工作! 在这种情况下，kubelet 是pod 的控制器。

到目前为止，大部分的内容可能都不太令人惊讶--但对于其他一些主题来说，这是一个很好的背景材料。


### 2. Group, Version 和 Resource 确定 APIs.
Group, Version 和 Kind 确定对象.
kubernetes 中的大多数 API 都是处理对象的。

对象和一个 group, version, kind 和 resource 绑定:

The kind is the familiar name you see at the top of a kube manifest. kind: Deployment, kind: Role, etc.
Each object is accessible via an API endpoint. Every kind is associated with some resource, which is the name used to access the object via the API. For most objects, the resource is just a variant of the kind name (i.e. Kind: Pod is accessible via the resource type pods). Some APIs may expose the same Kind under different resource names, but it is rare.
Each kind has a set of versions, which may have different schemas.
Each kind is organized into a group.
The apiVersion is a combination of the group and version for a specific object.

kind 是你在 kube 对象清单顶部看到的熟悉的名字。 例如，kind: Deployment，kind: Role，等等。
每个对象都可以通过一个 API 端点来访问。每个 kind 都与一些 resource 相关联，这是用于通过 API 访问对象的名称。对于大多数对象，reresource 只是 kind 名称的一个变体（例如，Kind:Pod 可以通过 pods resource 类型访问）。有些 API 可能会在不同的 resource 名称下暴露相同的 Kind，但这是很罕见的。
每个 kind 都有一组 versions，它们可能有不同的模式。
每个 kind 被组织成一个 group。
apiVersion 是一个特定对象的 group 和 version 的组合。

看一个单个对象：

```
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: default
  name: pod-reader
rules:
- apiGroups: [""] 
  resources: ["pods"]
  verbs: ["get", "watch", "list"]
```

这表明 group 是 rbac.authorization.k8s.io，version 是 v1 和 kind 是 Role。

对象中没有任何东西告诉你 resource 是什么-kube apiserver 维护着 resource 类型 <-> kind 的映射，kubectl 和 client-go 等kube 客户端也是如此。在这些客户端项目和相关文档中，这被称为 "REST Mapping"。

一旦你知道了 resource，就有了建立 URL 的简单规则，例如：

/apis/GROUP/VERSION/RESOURCE/NAME 用于获取集群范围的对象。
/apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME 用于获取 Namespace 范围的对象。
在 api-concepts 文档中有更多细节。

### 3. 对象可以在所有的 api 版本中访问

任何给定了 Group 和 Kind 的对象，可以通过 apiserver 支持的全部版本访问。

我可以在 v1beta1 创建一个 ingress 对象，然后在 v1 获得同样的对象。这些版本有完全不同的 schema，但 API 会将其转换为我请求的版本。或者，我可以在 v1 创建一个 ingress 对象，然后在 v1beta1 获得它。

如果你不请求一个特定的版本，kubectl 将以 api 的首选版本请求对象，这可能与你创建的版本不同。

你可以用 kubectl get --raw /apis/GROUP 来了解首选版本是什么。例如，要找到 ingress 的支持的版本和首选版本

```
$ kubectl get --raw /apis/networking.k8s.io
{
  "kind": "APIGroup",
  "apiVersion": "v1",
  "name": "networking.k8s.io",
  "versions": [
    {
      "groupVersion": "networking.k8s.io/v1",
      "version": "v1"
    },
    {
      "groupVersion": "networking.k8s.io/v1beta1",
      "version": "v1beta1"
    }
  ],
  "preferredVersion": {
    "groupVersion": "networking.k8s.io/v1",
    "version": "v1"
  }
}
```

### 4. 存储在 etcd 中的对象的版本可能与提交的版本和首选版本不同。

For every group and resource, the kube-apiserver knows the:
对于每个 group 和 resource ，kube-apiserver 知道：

served versions - the list of versions that are available in the api
decodeable versions - the list of versions the apiserver knows how to decode from storage. This may be different from served versions.

服务的版本--api 中可用的版本列表
可解码版本 - apiserver 知道如何从存储中解码的版本列表。这可能与服务的版本不同。

storage or encodeable version - the version the apiserver will convert to before storing in etcd
preferred version. kubectl will request with this version if not otherwise specified.

存储或可编码版本--apiserver 在存储到 etcd 之前将转换为该版本。
如果没有指定，kubectl 将使用该版本进行请求。

If you submit an object to the apiserver and it doesn't match the storage version, the apiserver will convert it to the storage version before storing it in etcd. (To be more precise, it first converts it to an internal version, before converting it back to the storage version etcd, but this is an implementation detail.)

如果你向 apiserver 提交一个对象，而它与存储版本不匹配，apiserver 将在将其存储到 etcd 之前将其转换为存储版本。(更准确地说，它首先将其转换为内部版本，然后再将其转换回存储版本 etcd，但这是一个实现细节）

There isn't a user-facing way to determine the storageversion for an API at runtime (at least not yet).

没有一种面向用户的方法可以在运行时确定一个 API 的存储版本（至少现在还没有）。

The storage version is usually the preferred version, but this can be overridden.
存储版本通常是首选版本，但这可以被覆盖。


For example, in kube 1.20, the preferred version of ingress is v1, but the storage version is v1beta1. This can be seen by looking at the data the apiserver stores in etcd directly:

例如，在 kube 1.20 中，ingress 的首选版本是 v1，但存储版本是 v1beta1。这可以通过直接查看 apiserver 存储在 etcd 中的数据来了解：

### 5. 改变一个对象的存储版本需要用较新的 apiserver 写入

Since the storage version is hardcoded in kube-apiserver, the only way to have an object's storage version updated is to update to a newer kube-apiserver with a different storage version configured for the object's API.

由于存储版本在kube-apiserver中是硬编码的，要想让一个对象的存储版本更新，唯一的办法就是更新到一个较新的kube-apiserver，为该对象的API配置一个不同的存储版本。

Once the apiserver is on a newer version with a new storage version, the object must be overwritten - it is not automatically converted (more on automatic conversion later)

一旦apiserver进入新的存储版本，该对象必须被覆盖--它不会被自动转换（后面会有更多关于自动转换的内容）。

举个例子：

Creates an ingress at v1 in kube 1.20 - which stores it at v1beta1
Updates the apiserver to 1.21
Checks that the data in etcd is still at v1beta1
Overwrites the ingress with the new apiserver to see it stored at v1

在kube 1.20中创建一个v1的入口--将其存储在v1beta1中
将apiserver更新到1.21
检查etcd中的数据是否仍在v1beta1处
用新的apiserver覆盖ingress，以看到它存储在v1的位置


### 6. API versions may have ratcheting validation (but are still round-trippable)
API版本可能有棘轮验证（但仍然是可圆滑的）。

The apiserver may choose to ratchet validation between versions - something that may have been valid under an old api version may not be valid under the new apiversion.

apiserver可能会选择在不同的版本之间增加验证--在旧的api版本下有效的东西，在新的apiversion下可能就无效了

Alone, this is probably not suprising. What might be surprising is the way ratcheting validation can interact with version round-tripping: just because you can get an object from the apiserver doesn't mean that you can create that exact same object.

单独来看，这可能并不令人惊讶。可能令人惊讶的是棘轮验证与版本往返的交互方式：你能从apiserver获得一个对象并不意味着你能创建完全相同的对象。

For example, the CustomResourceDefinition API employs ratcheting validation between v1beta1 and v1 to enforce structural schemas under v1.

例如，CustomResourceDefinition API在v1beta1和v1之间采用了棘轮式验证，以强制执行v1下的结构模式。

This means that:

You can create a v1beta1 CRD with a non-structural schema
You can get that CRD at from the v1 CRD api (versions are round-trippable)
If you delete the CRD, and recreate it with the v1 CRD that you just got from the API, it will fail to create
You can update that CRD at v1 after it's been created at v1beta1 (the validation is ratcheting)

你可以用一个非结构性模式创建一个v1beta1的CRD。
你可以从v1版CRD api中获得该CRD（版本是可循环的）。
如果你删除了这个CRD，然后用你刚从API那里得到的v1版CRD重新创建它，它将无法创建。
你可以在v1beta1版本创建CRD后，在v1版本更新它（验证是渐进式的）。

00:00

### 7. 存在 StorageVersion API

In 1.20+, there is a StorageVersion API that can provide information about objects stored in etcd, but it must be explicitly enabled.

在1.20+版本中，有一个StorageVersion API，可以提供存储在etcd中的对象的信息，但它必须明确启用。

This is the config needed to enabled the API in kind:

这是启用API实物所需的配置。


```
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
featureGates:
  StorageVersionAPI: true
  APIServerIdentity: true
runtimeConfig:
  "internal.apiserver.k8s.io/v1alpha1": "true"
```

Once enabled, for each group/resource, the API provides:

the current set of versions that can be decoded
the version that is used for encoding - i.e. the storage version, used to encode the object to store in etcd.
The API provides this information for every instance of the apiserver.

This API is not currently user-facing (hence the internal prefix). It is used to make decisions around storage versions during an apiserver upgrade, where there may be multiple apiservers running at multiple versions. The enhancement has more detail, see also the API documentation.

Here's an example for the deployment API:

apiVersion: internal.apiserver.k8s.io/v1alpha1
kind: StorageVersion
metadata:
  creationTimestamp: "2021-06-04T17:16:57Z"
  name: apps.deployments
  resourceVersion: "52"
  uid: 0b80b0f3-72b0-4af6-adfd-e93eb4b4c29f
spec: {}
status:
  commonEncodingVersion: apps/v1
  conditions:
  - lastTransitionTime: "2021-06-04T17:16:57Z"
    message: Common encoding version set
    reason: CommonEncodingVersionSet
    status: "True"
    type: AllEncodingVersionsEqual
  storageVersions:
  - apiServerID: kube-apiserver-803c62b1-340f-4055-93ca-44aba8a35574
    decodableVersions:
    - apps/v1
    - apps/v1beta2
    - apps/v1beta1
    encodingVersion: apps/v1
In this case, since there is only one apiserver, we can be confident that the deployment will be stored at apps/v1.

8. Install the kube-storage-version-migrator to migrate storage versions automatically
In a previous section, we saw that an object needs to be rewritten with a new apiserver in order for the storage version to change.

By default in kubernetes, nothing performs this operation. The kube-storage-version-migrator is an optional component that will automate the get-and-put workflow over all objects in the cluster.

00:00

The kube-storage-version-migrator is enabled by default in OpenShift, but it does not run automatically (it must be triggered manually).

### 9. CRD 定义了新的 API（不仅仅是对象）。

When you create a CRD to define a new object in the api, you are defining all of the same things that the apiserver defines for core apis:

the group, kind, and resourcetype for a new type of object
the served versions
the storage version
the decodeable versions
schemas for all decodable versions
whether the objects are namespace or cluster scoped
new url endpoints in the API
The new APIs that are generated will follow the kubernetes api conventions: that means that they are roundtrippable and there can only be a single storage version.

10. All APIs are cluster scoped, even scope: Namespaced CRDs
CRD's have a scope field.

This determines the scope of objects that you can create, it does not scope the availability of the api itself.

If scope is set to Cluster, then the API routes look like:

/apis/GROUP/VERSION/RESOURCE/NAME
If instead, scope is set to Namespaced, API routes look like:

/apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME
And namespaced resources across all namespaces can be queried with:

/apis/GROUP/VERSION/RESOURCETYPE
In both the Cluster and Namespaced scoped APIs, the Group and Version have been claimed for the entire cluster. There is no notion of an API that is only available in a single namespace.

### 11. 一个 CRD 的存储版本决定了新对象的存储方式。

Just like kube-apiserver picks the version to use when storing in etcd, as a CRD developer you must pick the version to store in etcd as well.

就像kube-apiserver在存储到etcd时选择使用的版本一样，作为CRD开发者，你也必须选择存储到etcd的版本。

The stored: true flag on a CRD version indicates how objects will be stored going forward. It does not affect existing stored objects.

CRD版本上的存储：true标志表明对象将如何被存储下去。它不影响现有的存储对象。

00:00

12. CRD's storedVersions lists every version that has been a stored version (not what is actually in etcd)
### 12. CRD 的 storageVersions 列出了每一个曾是存储版本的版本（而不是实际在etcd中的版本）。

The status block of a crd has a storedVersions field:

```
status:
  acceptedNames:
    kind: CronTab
    listKind: CronTabList
    plural: crontabs
    shortNames:
    - ct
    singular: crontab
  conditions:
  - lastTransitionTime: "2021-06-16T14:47:48Z"
    message: no conflicts found
    reason: NoConflicts
    status: "True"
    type: NamesAccepted
  - lastTransitionTime: "2021-06-16T14:47:48Z"
    message: the initial names have been accepted
    reason: InitialNamesAccepted
    status: "True"
    type: Established
  storedVersions:
  - v1beta1
  - v1
```

This field indicates every version that has been a stored version (i.e. has had storage: true set in the spec) and has no relationship to what stored versions exist in etcd.


### 13. 你不能从 CRD 中删除一个版本，直到它被从状态中移除。
.status.storedVersions, being a record of what versions have previously been set as the stored version for the api, indicate that there might still be data in etcd stored under those versions. You don't want to remove a decodeable version until there is nothing left in storage that might need to be decoded.

For this reason, it's not possible to entirely remove a version from a CRD if that version is listed as a storedVersion.

00:00

Note that served can be set to false for any version - a stored version that is no longer served can still be fetched under newer apiversions.

### 14. 存储版本必须从CRD的状态中手动删除

Just like non-CRD-defined kube apis, objects need to be updated to the new storage version via a write. The kube-storage-version-migrator can automate this for CRs as well.

However, once that migration is complete, it's a manual process to remove unused storage versions from a CRD's .status.storedVersion.

kubectl has no direct support for editing status. In this example, we remove the version with curl.


## 15. 在不同版本之间收紧一个 schema 是不安全的

Some kube apis may have ratcheting validation. But generally this validation tightening does not occur in the API schema - tightening validation can cause clients to have incorrect assumptions about data.

This is a scencario that can happen:

a field in v1 of an API has a tighter schema than v1beta1
the storage version is v1 for the API
an object is created at v1beta1 that doesn't comply with the tightened v1 schema
the object is accepted, because it was created at v1beta1, and the storage version is v1, so it is stored as a v1 object
the object in etcd is an "invalid" v1 object.
Similar situations arise if you update the schema of a single version to be tighter, after objects have already been created.

Any client that is using the schema to have expectations about api repsonses may not do the right thing if validation is tightened between versions.

00:00

16. kube-storage-version-migrator will fail for tightened schemas
kube-storage-version-migator does a get/update for each object. If the schema has been tightened (or ratcheting validation has not been implemented to only apply to create), then it will fail.

00:00

Appendix: kind, yvim, auger, etcdctl
In an attempt to be succinct, the demos make use of several tools.

kind is used to spin up clusters easily locally.

To inspect the contents of etcd with a kind cluster, first configure it to expose the etcd port:

kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
nodes:
- role: control-plane
  extraPortMappings:
  - containerPort: 2379
    hostPort: 2379
Then configure etcdctl to be able to talk to the kind etcd:

docker cp kind-control-plane:/etc/kubernetes/pki/etcd/ca.crt ca.crt
docker cp kind-control-plane:/etc/kubernetes/pki/etcd/peer.crt peer.crt
docker cp kind-control-plane:/etc/kubernetes/pki/etcd/peer.key peer.key
export ETCDCTL_CACERT=./ca.crt 
export ETCDCTL_CERT=./peer.crt 
export ETCDCTL_KEY=./peer.key 

# confirm it works
etcdctl get /registry  --prefix=true
I occasionally use yvim, which is just an alias to open vim with the assumption that file is yaml (useful for piping from kubectl):

alias yvim='nvim -c "doautocmd Filetype yaml" -R -'
I also sometimes use auger to decode the protobuf-encoded objects stored in etcd. Auger is not usable out of the box, instead it needs to be built with references to a specific version of kube so that it has the correct object definitions.

Once it's built correctly, you can pipe directly from etcdctl:

etcdctl get /registry/ingress/default/name-virtual-host-ingress --print-value-only | auger decode
