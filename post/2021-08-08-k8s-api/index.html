<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta http-equiv=Cache-Control content="no-transform"><meta http-equiv=Cache-Control content="no-siteapp"><meta name=generator content="Hugo 0.124.1"><title>(译)16 件关于 Kubernetes APIs 和 CRDs 你所不知道的事情 - 大海里的木鱼</title>
<meta name=author content="木鱼"><meta name=description content="A minimal Hugo theme with nice theme color."><meta name=keywords content="kubernetes"><meta property="og:title" content="(译)16 件关于 Kubernetes APIs 和 CRDs 你所不知道的事情"><meta name=twitter:title content="(译)16 件关于 Kubernetes APIs 和 CRDs 你所不知道的事情"><meta property="og:type" content="article"><meta property="og:url" content="https://www.pigflying.net/post/2021-08-08-k8s-api/"><meta property="og:description" content="第 15 个会震惊到你！ 如果你对 kubernetes 很熟悉，那么你很可能对 kubernetes API 和 controller 有所了解：调和循环查看 api 中存储的数据，并且努力让集群中的状态和声明的 API 状态相匹配。 这是一个相当强大的模式，随着时间的推移，已经证明了它的价值。"><meta name=twitter:description content="第 15 个会震惊到你！ 如果你对 kubernetes 很熟悉，那么你很可能对 kubernetes API 和 controller 有所了解：调和循环查看 api 中存储的数据，并且努力让集群中的状态和声明的 API 状态相匹配。 这是一个相当强大的模式，随着时间的推移，已经证明了它的价值。"><meta property="og:image" content="https://www.pigflying.net/img/og.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.pigflying.net/img/og.png"><meta property="article:published_time" content="2021-08-08T09:34:00+08:00"><meta property="article:modified_time" content="2021-08-08T09:34:00+08:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://www.pigflying.net/assets/css/fuji.min.css><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-34929546-1")</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-34929546-1"></script></head><body><script data-cfasync=false>var fujiThemeData=localStorage.getItem("fuji_data-theme");fujiThemeData?fujiThemeData!=="auto"&&document.body.setAttribute("data-theme",fujiThemeData==="dark"?"dark":"light"):localStorage.setItem("fuji_data-theme","auto")</script><div id=header><div class="container yue"><div id=brand><a href=https://www.pigflying.net/>大海里的木鱼</a></div></div><div id=nav role=navigation><a href=/>Home</a>
<a href=/archives/>Archives</a>
<a href=/about/>About</a>
<a href=/index.xml>RSS</a></div></div><div id=main><div class="container yue"><div class="col-12 col-md-9 float-left content"><div class=hentry itemscope itemtype=http://schema.org/Article><h1 class=entry-title itemprop=name>(译)16 件关于 Kubernetes APIs 和 CRDs 你所不知道的事情</h1><div class=entry-meta><time class=updated itemprop=datePublished pubdate>2021-08-08
</time><span class="author vcard"><a class=fn itemprop=author href=/>木鱼</a></span></div><div class=entry-content itemprop=articleBody><p>第 15 个会震惊到你！</p><p>如果你对 kubernetes 很熟悉，那么你很可能对 kubernetes API 和 controller 有所了解：调和循环查看 api 中存储的数据，并且努力让集群中的状态和声明的 API 状态相匹配。</p><p>这是一个相当强大的模式，随着时间的推移，已经证明了它的价值。但是，尽管核心思想看起来很简单，但一旦你从表面上看，有很多细节可能会令人惊讶。</p><h3 id=1-并不是所有的-kubernetes-apis-都有对应的控制器>1. 并不是所有的 kubernetes apis 都有对应的控制器</h3><p>kubernetes 控制平面通常分为两种职责：API 和控制器。</p><p>大多数 kubernetes 发行版都在单独的 Pod 中运行核心 apis 和核心控制器:</p><pre><code class=language-bash>$ k -n kube-system get pods
NAME                                         READY   STATUS    RESTARTS   AGE
kube-apiserver-kind-control-plane            1/1     Running   0          23m
kube-controller-manager-kind-control-plane   1/1     Running   0          23m
</code></pre><p><code>kube-apiserver</code> 主要负责将 api 数据存储到后端存储中，通常是 etcd。</p><p><code>kube-controller-manager</code> 在这些 api 的内容上运行一系列的调和循环。随着时间的推移，这些控制器确保达到（或不达到）预期的状态，并通过 api 报告状态。</p><p>而通常这就是 kubernetes API 的工作方式：通过 API 创建期望的状态，期望的状态被存储，控制器以非同步方式工作，使集群状态与期望的状态相匹配。</p><p>例如：deployment api 允许你创建一个定义 Pod 的 deployment对象。Deployment 控制器（在controller-manager中运行）根据deployment 对象创建副本集并更新状态。</p><p>如果你完全停止控制器管理器，并试图创建一个像 deployment 这样的对象，这一点就特别明显。</p><p>如果没有 controller-manager 运行，deployment 对象（仍然可以被创建！），但是没有状态，也不会创建 Pod。</p><p>但实际上，有一小部分 api 并不直接由控制器以这种方式管理。<code>SubjectAccessReview</code> 就是其中之一。</p><p>即使没有 controller-manager，SubjectAccessReview 也会响应一个状态。</p><p>还有一个你可能很熟悉的 api，它也可以在没有 controller-manager 的情况下使用。</p><p>Pods 在没有 controller-manager 的情况下也可以工作! 在这种情况下，kubelet 是 pod 的控制器。</p><p>到目前为止，大部分的内容可能都不太令人惊讶。但对于其他一些主题来说，这是一个很好的背景材料。</p><h3 id=2-group-version-和-resource-确定-apis>2. Group, Version 和 Resource 确定 APIs.</h3><p>Group, Version 和 Kind 确定对象.
kubernetes 中的大多数 API 都是处理对象的。</p><p>对象和一个 group, version, kind 和 resource 绑定:</p><p>kind 是你在 kube 对象清单顶部看到的熟悉的名字。 例如，kind: Deployment，kind: Role，等等。
每个对象都可以通过一个 API 端点来访问。每个 kind 都与一些 resource 相关联，这是用于通过 API 访问对象的名称。对于大多数对象，reresource 只是 kind 名称的一个变体（例如，Kind:Pod 可以通过 pods resource 类型访问）。有些 API 可能会在不同的 resource 名称下暴露相同的 Kind，但这是很罕见的。
每个 kind 都有一组 versions，它们可能有不同的模式。
每个 kind 被组织成一个 group。
apiVersion 是一个特定对象的 group 和 version 的组合。</p><p>看一个单个对象：</p><pre><code>apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: default
  name: pod-reader
rules:
- apiGroups: [&quot;&quot;] 
  resources: [&quot;pods&quot;]
  verbs: [&quot;get&quot;, &quot;watch&quot;, &quot;list&quot;]
</code></pre><p>这表明 group 是 rbac.authorization.k8s.io，version 是 v1 和 kind 是 Role。</p><p>这个对象中没有任何东西告诉你 resource 是什么。kube apiserver 维护着 resource 类型 &lt;-> kind 的映射，kubectl 和 client-go 等 kube 客户端也是如此。在这些客户端项目和相关文档中，这被称为 &ldquo;REST Mapping&rdquo;。</p><p>一旦你知道了 resource，就有了建立 URL 的简单规则，例如：</p><p>/apis/GROUP/VERSION/RESOURCE/NAME 用于获取集群范围的对象。
/apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME 用于获取 Namespace 范围的对象。
在 <a href=https://kubernetes.io/docs/reference/using-api/api-concepts/ target=_blank>api-concepts</a> 文档中有更多细节。</p><h3 id=3-对象可以在所有的-api-版本中访问>3. 对象可以在所有的 api 版本中访问</h3><p>任何给定了 Group 和 Kind 的对象，可以通过 apiserver 支持的全部版本访问。</p><p>我可以在 v1beta1 创建一个 ingress 对象，然后在 v1 获取同样的对象。这些版本有完全不同的 schema，但 API 会将其转换为我请求的版本。或者，我可以在 v1 创建一个 ingress 对象，然后在 v1beta1 获取它。</p><p>如果你不请求一个特定的版本，kubectl 将以 api 的首选版本请求对象，这可能与你创建的版本不同。</p><p>你可以用 kubectl get &ndash;raw /apis/GROUP 来了解首选版本是什么。例如，要找到 ingress 的支持的版本和首选版本</p><pre><code>$ kubectl get --raw /apis/networking.k8s.io
{
  &quot;kind&quot;: &quot;APIGroup&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  &quot;name&quot;: &quot;networking.k8s.io&quot;,
  &quot;versions&quot;: [
    {
      &quot;groupVersion&quot;: &quot;networking.k8s.io/v1&quot;,
      &quot;version&quot;: &quot;v1&quot;
    },
    {
      &quot;groupVersion&quot;: &quot;networking.k8s.io/v1beta1&quot;,
      &quot;version&quot;: &quot;v1beta1&quot;
    }
  ],
  &quot;preferredVersion&quot;: {
    &quot;groupVersion&quot;: &quot;networking.k8s.io/v1&quot;,
    &quot;version&quot;: &quot;v1&quot;
  }
}
</code></pre><h3 id=4-存储在-etcd-中的对象的版本可能与提交的版本和首选版本不同>4. 存储在 etcd 中的对象的版本可能与提交的版本和首选版本不同。</h3><p>对于每个 group 和 resource ，kube-apiserver 知道：</p><p>服务的版本：api 中可用的版本列表
可解码版本：apiserver 知道如何从存储中解码的版本列表。这可能与服务的版本不同。
存储或可编码版本：apiserver 在存储到 etcd 之前将转换为该版本。
首选版本：如果没有指定，kubectl 将使用该版本进行请求。</p><p>如果你向 apiserver 提交一个对象，而它与存储版本不匹配，apiserver 将在将其存储到 etcd 之前将其转换为存储版本。(更准确地说，它首先将其转换为内部版本，然后再将其转换回存储版本 etcd，但这是一个实现细节）</p><p>没有一种面向用户的方法可以在运行时确定一个 API 的存储版本（至少现在还没有）。
存储版本通常是首选版本，但这可以被覆盖。</p><p>例如，在 kube 1.20 中，ingress 的首选版本是 v1，但存储版本是 v1beta1。这可以通过直接查看 apiserver 存储在 etcd 中的数据来了解：</p><h3 id=5-改变一个对象的存储版本需要用较新的-apiserver-写入>5. 改变一个对象的存储版本需要用较新的 apiserver 写入</h3><p>由于存储版本在 kube-apiserver 中是硬编码的，要想让一个对象的存储版本更新，唯一的办法就是更新到一个较新的 kube-apiserver，为该对象的API配置一个不同的存储版本。</p><p>一旦 apiserver 进入新的存储版本，该对象必须被覆盖。它不会被自动转换（后面会有更多关于自动转换的内容）。</p><p>举个例子：</p><ul><li>在 kube 1.20 中创建一个 v1 的 ingress。将其存储在 v1beta1 中。</li><li>将 apiserver 更新到 1.21。</li><li>检查 etcd 中的数据是否仍在 v1beta1 处。</li><li>用新的 apiserver 覆盖 ingress，以看到它存储在 v1 的位置。</li></ul><h3 id=6-api-版本可能有棘轮验证但仍然是可圆滑的>6. API 版本可能有棘轮验证（但仍然是可圆滑的）</h3><p>apiserver 可能会选择在不同的版本之间增加验证。在旧的 api 版本下有效的东西，在新的 apiversion 下可能就无效了</p><p>单独来看，这可能并不令人惊讶。可能令人惊讶的是棘轮验证与版本往返的交互方式：你能从 apiserver 获得一个对象并不意味着你能创建完全相同的对象。</p><p>例如，CustomResourceDefinition API 在 v1beta1 和 v1 之间采用了棘轮式验证，以强制执行v1下的结构模式。</p><p>这意味着：</p><ul><li>你可以用一个非结构性模式创建一个 v1beta1 的 CRD。</li><li>你可以从 v1 版 CRD api 中获得该 CRD（版本是可循环的）。</li><li>如果你删除了这个 CRD，然后用你刚从 API 那里得到的 v1 版 CRD 重新创建它，它将无法创建。</li><li>你可以在 v1beta1版本创建 CRD 后，在 v1 版本更新它（验证是渐进式的）。</li></ul><h3 id=7-存在-storageversion-api>7. 存在 StorageVersion API</h3><p>在 1.20+ 版本中，有一个 StorageVersion API，可以提供存储在 etcd 中的对象的信息，但它必须明确启用。</p><p>这是启用 API 类型所需的配置。</p><pre><code>kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
featureGates:
  StorageVersionAPI: true
  APIServerIdentity: true
runtimeConfig:
  &quot;internal.apiserver.k8s.io/v1alpha1&quot;: &quot;true&quot;
</code></pre><p>一旦启用，对于每个 group/resource，API 提供：</p><ul><li>当前可以解码的版本集合</li><li>用于编码的版本 - 即存储版本，用于编码对象以存储在etcd中。</li></ul><p>API 为 apiserver 的每个实例提供这一信息。</p><p>这个 API 目前不是面向用户的（因此有内部前缀）。它用于在 apiserver 升级期间围绕存储版本做出决定，其中可能有多个 apiservers 以多个版本运行。增强版有更多的细节，也请看API文档。</p><p>这里有一个 deployment API 的例子：</p><pre><code>apiVersion: internal.apiserver.k8s.io/v1alpha1
kind: StorageVersion
metadata:
  creationTimestamp: &quot;2021-06-04T17:16:57Z&quot;
  name: apps.deployments
  resourceVersion: &quot;52&quot;
  uid: 0b80b0f3-72b0-4af6-adfd-e93eb4b4c29f
spec: {}
status:
  commonEncodingVersion: apps/v1
  conditions:
  - lastTransitionTime: &quot;2021-06-04T17:16:57Z&quot;
    message: Common encoding version set
    reason: CommonEncodingVersionSet
    status: &quot;True&quot;
    type: AllEncodingVersionsEqual
  storageVersions:
  - apiServerID: kube-apiserver-803c62b1-340f-4055-93ca-44aba8a35574
    decodableVersions:
    - apps/v1
    - apps/v1beta2
    - apps/v1beta1
    encodingVersion: apps/v1
</code></pre><p>在这种情况下，由于只有一个 apiserver，我们可以确信部署将被存储在 apps/v1 版本中。</p><ol start=8><li>安装kube-storage-version-migrator来自动迁移存储版本</li></ol><p>在上一节中，我们看到一个对象需要用一个新的apiserver来重写，以便改变存储版本。</p><p>在kubernetes中，默认情况下没有任何东西可以执行这个操作。kube-storage-version-migrator是一个可选的组件，它将对集群中的所有对象自动进行获取和输入工作流程。</p><p>在 OpenShift 中，kube-storage-version-migrator 是默认启用的，但它并不自动运行（必须手动触发）。</p><h3 id=9-crd-定义了新的-api不仅仅是对象>9. CRD 定义了新的 API（不仅仅是对象）。</h3><p>当你创建 CRD 来定义 api 中的一个新对象时，你所定义的东西与 apiserver 为核心 apis 所定义的东西是一样的：</p><ul><li>一个新类型的对象的组、种类和资源类型</li><li>服务的版本</li><li>存储的版本</li><li>可解码的版本</li><li>所有可解码版本的模式</li><li>对象是命名空间还是集群范围的</li><li>API 中的新 URL 端点</li></ul><p>生成的新 API 将遵循 kubernetes api 惯例：这意味着它们是可轮换的，只能有一个存储版本。</p><h3 id=10-所有的-api-都是集群范围内的甚至有命名空间的-crd>10. 所有的 API 都是集群范围内的，甚至有命名空间的 CRD</h3><p>CRD有一个 scope 字段。</p><p>这决定了你可以创建的对象的范围，它不包括 api 本身的可用性。</p><p>如果范围设置为 Cluster，那么 API 路由看起来像：</p><p>/apis/GROUP/VERSION/RESOURCE/NAME</p><p>如果相反，范围被设置为Namespaced，API路由看起来像：</p><p>/apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME</p><p>而跨越所有命名空间的命名空间资源可以通过以下方式进行查询：</p><p>/apis/GROUP/VERSION/RESOURCETYPE</p><p>在集群和命名空间范围的API中，组和版本已经被整个集群所认可。不存在只在单一命名空间中可用的API的概念。</p><h3 id=11-一个-crd-的存储版本决定了新对象的存储方式>11. 一个 CRD 的存储版本决定了新对象的存储方式。</h3><p>就像kube-apiserver在存储到etcd时选择使用的版本一样，作为CRD开发者，你也必须选择存储到etcd的版本。</p><p>CRD版本上的存储：true标志表明对象将如何被存储下去。它不影响现有的存储对象。</p><h3 id=12-crd-的-storageversions-列出了每一个曾是存储版本的版本而不是实际在etcd中的版本>12. CRD 的 storageVersions 列出了每一个曾是存储版本的版本（而不是实际在etcd中的版本）。</h3><p>crd 的状态块有一个 storedVersions 字段。</p><pre><code>status:
  acceptedNames:
    kind: CronTab
    listKind: CronTabList
    plural: crontabs
    shortNames:
    - ct
    singular: crontab
  conditions:
  - lastTransitionTime: &quot;2021-06-16T14:47:48Z&quot;
    message: no conflicts found
    reason: NoConflicts
    status: &quot;True&quot;
    type: NamesAccepted
  - lastTransitionTime: &quot;2021-06-16T14:47:48Z&quot;
    message: the initial names have been accepted
    reason: InitialNamesAccepted
    status: &quot;True&quot;
    type: Established
  storedVersions:
  - v1beta1
  - v1
</code></pre><p>这个字段表示每一个作为存储版本的版本（即在规范中设置了存储：true），与etcd中存在的存储版本没有关系。</p><h3 id=13-你不能从-crd-中删除一个版本直到它被从状态中移除>13. 你不能从 CRD 中删除一个版本，直到它被从状态中移除。</h3><p>.status.storedVersions，是以前被设置为api的存储版本的记录，表明在etcd中可能仍有数据存储在这些版本下。你不想删除一个可解码的版本，直到存储中没有任何可能需要解码的东西了。</p><p>由于这个原因，如果一个版本被列为存储版本，就不可能完全从CRD中删除该版本。</p><p>请注意，对于任何版本，served都可以被设置为false&ndash;不再提供服务的存储版本仍然可以在较新的apiversions下被取走。</p><h3 id=14-存储版本必须从crd的状态中手动删除>14. 存储版本必须从CRD的状态中手动删除</h3><p>就像非CRD定义的kube apis一样，对象需要通过写操作更新到新的存储版本。kube-storage-version-migrator也可以为CRs自动完成这一工作。</p><p>然而，一旦迁移完成，从CRD的.status.storedVersion中删除未使用的存储版本是一个手动过程。</p><p>kubectl没有直接支持编辑状态。在这个例子中，我们用curl删除版本。</p><h2 id=15-在不同版本之间收紧一个-schema-是不安全的>15. 在不同版本之间收紧一个 schema 是不安全的</h2><p>一些kube apis可能有棘轮验证。但一般来说，这种验证的收紧不会发生在API模式中&ndash;收紧验证会导致客户端对数据有不正确的假设。</p><p>这是一个可能发生的情况。</p><p>一个API的v1版的字段比v1beta1版的模式更严格
该API的存储版本是v1
在v1beta1版本创建的对象不符合v1版本更严格的模式。
该对象被接受，因为它是在v1beta1创建的，而且存储版本是v1，所以它被存储为v1对象
etcd中的对象是一个 &ldquo;无效的 &ldquo;v1对象。
如果你在对象已经被创建之后，将单一版本的模式更新得更严格，也会出现类似的情况。</p><p>如果在版本之间加强验证，任何使用模式对api响应有期望的客户可能不会做正确的事情。</p><h3 id=16-kube-storage-version-migrator-will-fail-for-tightened-schemas>16. kube-storage-version-migrator will fail for tightened schemas</h3><p>kube-storage-version-migator对每个对象进行获取/更新。如果模式已经被收紧（或者棘轮验证没有被实现，只适用于创建），那么它将失败。</p><h3 id=附录-kind-yvim-auger-etcdctl>附录: kind, yvim, auger, etcdctl</h3><p>为了简明扼要，这些演示使用了几种工具。</p><p>kind 是本地快速创建集群的工具.</p><p>要想用同类集群检查etcd的内容，首先要配置它以暴露etcd端口。</p><pre><code>kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
nodes:
- role: control-plane
  extraPortMappings:
  - containerPort: 2379
    hostPort: 2379
</code></pre><p>然后配置etcdctl，使其能够与 kind 的 etcd 通信：</p><pre><code>docker cp kind-control-plane:/etc/kubernetes/pki/etcd/ca.crt ca.crt
docker cp kind-control-plane:/etc/kubernetes/pki/etcd/peer.crt peer.crt
docker cp kind-control-plane:/etc/kubernetes/pki/etcd/peer.key peer.key
export ETCDCTL_CACERT=./ca.crt 
export ETCDCTL_CERT=./peer.crt 
export ETCDCTL_KEY=./peer.key 
# confirm it works
etcdctl get /registry  --prefix=true
</code></pre><p>我偶尔会使用yvim，这只是一个别名，用来打开vim，假设文件是yaml（对kubectl的管道连接很有用）。</p><p><code>alias yvim='nvim -c "doautocmd Filetype yaml" -R -'</code></p><p>我有时也使用Auger来解码存储在etcd中的protobuf编码的对象。Auger不是开箱即用的，相反，它需要通过引用特定版本的kube来构建，以便它有正确的对象定义。</p><p>一旦它被正确构建，你就可以直接从etcdctl进行管道连接：</p><p><code>etcdctl get /registry/ingress/default/name-virtual-host-ingress --print-value-only | auger decode</code></p><p>原文: <a href=https://evancordell.com/posts/kube-apis-crds/ target=_blank>https://evancordell.com/posts/kube-apis-crds/</a></p></div></div><div class="license markdown-body"><blockquote><p>除特殊注明部分，本站内容采用 <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a> 进行许可。</p></blockquote></div></div></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>页面</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/about/>About</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>链接</h3><ul></ul></div><div class="sidebar-item sidebar-tags"><h3>标签</h3><div><span><a href=/tags/blogger/>Blogger</a>
</span><span><a href=/tags/google/>Google</a>
</span><span><a href=/tags/kubernetes/>Kubernetes</a>
</span><span><a href=/tags/other/>Other</a>
</span><span><a href=/tags/python/>Python</a>
</span><span><a href=/tags/tools/>Tools</a>
</span><span><a href=/tags/%E9%9A%8F%E7%AC%94/>随笔</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>目录</h3><nav id=TableOfContents><ul><li><ul><li><a href=#1-并不是所有的-kubernetes-apis-都有对应的控制器>1. 并不是所有的 kubernetes apis 都有对应的控制器</a></li><li><a href=#2-group-version-和-resource-确定-apis>2. Group, Version 和 Resource 确定 APIs.</a></li><li><a href=#3-对象可以在所有的-api-版本中访问>3. 对象可以在所有的 api 版本中访问</a></li><li><a href=#4-存储在-etcd-中的对象的版本可能与提交的版本和首选版本不同>4. 存储在 etcd 中的对象的版本可能与提交的版本和首选版本不同。</a></li><li><a href=#5-改变一个对象的存储版本需要用较新的-apiserver-写入>5. 改变一个对象的存储版本需要用较新的 apiserver 写入</a></li><li><a href=#6-api-版本可能有棘轮验证但仍然是可圆滑的>6. API 版本可能有棘轮验证（但仍然是可圆滑的）</a></li><li><a href=#7-存在-storageversion-api>7. 存在 StorageVersion API</a></li><li><a href=#9-crd-定义了新的-api不仅仅是对象>9. CRD 定义了新的 API（不仅仅是对象）。</a></li><li><a href=#10-所有的-api-都是集群范围内的甚至有命名空间的-crd>10. 所有的 API 都是集群范围内的，甚至有命名空间的 CRD</a></li><li><a href=#11-一个-crd-的存储版本决定了新对象的存储方式>11. 一个 CRD 的存储版本决定了新对象的存储方式。</a></li><li><a href=#12-crd-的-storageversions-列出了每一个曾是存储版本的版本而不是实际在etcd中的版本>12. CRD 的 storageVersions 列出了每一个曾是存储版本的版本（而不是实际在etcd中的版本）。</a></li><li><a href=#13-你不能从-crd-中删除一个版本直到它被从状态中移除>13. 你不能从 CRD 中删除一个版本，直到它被从状态中移除。</a></li><li><a href=#14-存储版本必须从crd的状态中手动删除>14. 存储版本必须从CRD的状态中手动删除</a></li></ul></li><li><a href=#15-在不同版本之间收紧一个-schema-是不安全的>15. 在不同版本之间收紧一个 schema 是不安全的</a><ul><li><a href=#16-kube-storage-version-migrator-will-fail-for-tightened-schemas>16. kube-storage-version-migrator will fail for tightened schemas</a></li><li><a href=#附录-kind-yvim-auger-etcdctl>附录: kind, yvim, auger, etcdctl</a></li></ul></li></ul></nav></div></div></aside></div><div id=footer><div class=container><p>&copy; Copyright 2009-2024 by 木鱼. Designed by <a href=http://lepture.com/ target=_blank>lepture</a></p></div></div><script defer src=/assets/js/fuji.min.js></script></body></html>